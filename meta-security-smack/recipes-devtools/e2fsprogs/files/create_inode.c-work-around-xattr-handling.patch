From 1cc08c76a6e221ddf7e07f7e41ee889f29f81dfc Mon Sep 17 00:00:00 2001
From: Patrick Ohly <patrick.ohly@intel.com>
Date: Wed, 3 Feb 2016 14:47:47 +0100
Subject: [PATCH] create_inode.c: work around xattr handling bug

When multiple xattrs are set for an inode, image creation only works
correctly when they get added to the image with increasing length of
their values. Otherwise reading values from the image fails with
ENOATTR.

It is unclear whether ext2fs_xattr_set() can (or should) be changed to
handle adding xattrs in arbitrary order. A proper solution is being
worked on in https://bugzilla.yoctoproject.org/show_bug.cgi?id=8992

Until that becomes clear, sorting in set_inode_xattr() avoids the
issue.

Upstream-Status: Inappropriate [https://bugzilla.yoctoproject.org/show_bug.cgi?id=8992]

Signed-off-by: Patrick Ohly <patrick.ohly@intel.com>
---

diff --git a/misc/create_inode.c b/misc/create_inode.c
index 0de5719..bf32015 100644
--- a/misc/create_inode.c
+++ b/misc/create_inode.c
@@ -124,6 +124,23 @@ static errcode_t set_inode_extra(ext2_filsys fs, ext2_ino_t ino,
 }
 
 #ifdef HAVE_LLISTXATTR
+struct xattr_entry {
+	const char *name;
+	size_t value_size;
+};
+static int xattrs_cmp_size(const void *a, const void *b)
+{
+	size_t size_a = ((const struct xattr_entry *)a)->value_size,
+		size_b = ((const struct xattr_entry *)b)->value_size;
+	if (size_a < size_b ) {
+		return -1;
+	} else if (size_a == size_b ) {
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
 static errcode_t set_inode_xattr(ext2_filsys fs, ext2_ino_t ino,
 				 const char *filename)
 {
@@ -131,7 +148,9 @@ static errcode_t set_inode_xattr(ext2_filsys fs, ext2_ino_t ino,
 	struct ext2_xattr_handle	*handle;
 	ssize_t				size, value_size;
 	char				*list = NULL;
-	int				i;
+	int				i, e;
+	int				num_xattrs;
+	struct xattr_entry		*xattrs = NULL;
 
 	size = llistxattr(filename, NULL, 0);
 	if (size == -1) {
@@ -165,9 +184,21 @@ static errcode_t set_inode_xattr(ext2_filsys fs, ext2_ino_t ino,
 		goto out;
         }
 
+	/* Reorder xattrs to avoid https://bugzilla.yoctoproject.org/show_bug.cgi?id=8992:
+	 * if security.ima is added to the image first, reading its value from the image
+	 * fails with "No such attribute". Adding it later works.
+	 */
+	num_xattrs = 0;
 	for (i = 0; i < size; i += strlen(&list[i]) + 1) {
+		num_xattrs++;
+	}
+	retval = ext2fs_get_mem(num_xattrs * sizeof(*xattrs), &xattrs);
+	if (retval) {
+		com_err(__func__, retval, _("while allocating memory"));
+		goto out;
+	}
+	for (i = 0, e = 0; i < size; i += strlen(&list[i]) + 1, e++) {
 		const char *name = &list[i];
-		char *value;
 
 		value_size = lgetxattr(filename, name, NULL, 0);
 		if (value_size == -1) {
@@ -177,13 +208,21 @@ static errcode_t set_inode_xattr(ext2_filsys fs, ext2_ino_t ino,
 				name, filename);
 			break;
 		}
+		xattrs[e].name = name;
+		xattrs[e].value_size = value_size;
+	}
+	qsort(xattrs, num_xattrs, sizeof(*xattrs), xattrs_cmp_size);
 
+	for (e = 0; e < num_xattrs; e++) {
+		const char *name = xattrs[e].name;
+		char *value;
+
+		value_size = xattrs[e].value_size;
 		retval = ext2fs_get_mem(value_size, &value);
 		if (retval) {
 			com_err(__func__, retval, _("while allocating memory"));
 			break;
 		}
-
 		value_size = lgetxattr(filename, name, value, value_size);
 		if (value_size == -1) {
 			ext2fs_free_mem(&value);
@@ -206,6 +245,7 @@ static errcode_t set_inode_xattr(ext2_filsys fs, ext2_ino_t ino,
 	}
  out:
 	ext2fs_free_mem(&list);
+	ext2fs_free_mem(&xattrs);
 	close_retval = ext2fs_xattrs_close(&handle);
 	if (close_retval) {
 		com_err(__func__, retval, _("while closing inode %u"), ino);
